# トークルーム仕様（単一モデル／表示フォールバック）

## 目的

- **DM/グループという区別を設けず**、すべてを「トークルーム」として扱う。
- 2人のルームで**ルーム名/アイコンが未設定**\*\*なら、各ユーザーにとっての**相手の名前・アイコンをそのまま表示**\*_\*する。_
- ルームに**名前またはアイコンが設定されている場合は常にそれを表示**する（人数に関わらず）。
- プロトコル拡張は使わず、**アプリ層メタデータと現在状態のみ**で成立させる。
- さらに、ユーザーが**自分視点で“DM的な扱いを受けているトークルーム”をワンタップで表示**できる直観的なUI（クイックビュー）を提供する。

## スコープ

- クライアント/サーバのアプリ層仕様。

## DMの送信

ActivityPub の `Create` で `Note` を送る際、`to` に受信者のアクター URI を1件
だけ指定するとDMとして扱われ、対応するトークルームが自動的に作成されます。

---

## 表示の基本ルール

1. ルームにユーザー設定の**名前/アイコン**がある → **それを表示**。
2. ルーム名/アイコンが**未設定**かつ**メンバーがちょうど2人** →
   **各ユーザーに対して相手のプロフィール（名前・アイコン）を表示**。
3. それ以外（例: 3人以上で未設定） → **自動生成表示**（例:
   メンバーの頭文字/複合アイコン、タイトルはメンバー名の簡易列挙）。

> 注:
> 自動生成名/アイコンは“未設定扱い”。ユーザーが明示入力/変更した場合のみ「設定あり」。

---

## データモデル（アプリ層）

**Room（永続）**

```json
{
  "roomId": "r1",
  "members": ["u1", "u2"],
  "displayName": null, // ユーザー設定のルーム名。未設定なら null
  "displayIcon": null, // ユーザー設定のルームアイコンURL等。未設定なら null
  "createdAt": 1730000000
}
```

**User（参照）**

```json
{ "userId": "u1", "profileName": "山田 太郎", "avatarUrl": "https://..." }
```

**Event（任意：監査/同期）**

```json
{ "type": "NameSet",      "value": "プロジェクトA", "by": "u1", "ts": 1730000300 }
{ "type": "NameCleared",  "by": "u1",               "ts": 1730000400 }
{ "type": "IconSet",      "value": "https://...",   "by": "u1", "ts": 1730000500 }
{ "type": "IconCleared",  "by": "u1",               "ts": 1730000600 }
{ "type": "MemberAdded",  "userId": "u3",           "by": "u1", "ts": 1730000100 }
{ "type": "MemberRemoved","userId": "u3",           "by": "u1", "ts": 1730000200 }
```

---

## UIフロー（作成/編集）

- **「〇〇さんとのトークを開始」**: 相手を選ぶだけで作成（2人・未設定）。→
  表示は相手のプロフィール。
- **「グループを作成」**: 別メニューで**名前・アイコンを設定**（必須 or
  推奨）。→ 常にルーム名/アイコンを表示。
- 途中から**名前/アイコンを設定/解除**できる（解除すると未設定扱いに戻り、2人なら相手表示にフォールバック）。

---

## 表示用ロジック（擬似コード）

```ts
function roomTitleFor(
  viewer: User,
  room: Room,
  users: Map<UserId, User>,
): string {
  if (room.displayName) return room.displayName;
  if (room.members.length === 2) {
    const otherId = room.members.find((id) => id !== viewer.userId)!;
    return users.get(otherId)?.profileName ?? "（名称未設定）";
  }
  return autoTitleFromMembers(room.members, users); // 例: 「太郎さん他3名」
}

function roomAvatarFor(
  viewer: User,
  room: Room,
  users: Map<UserId, User>,
): string | CompositeAvatar {
  if (room.displayIcon) return room.displayIcon;
  if (room.members.length === 2) {
    const otherId = room.members.find((id) => id !== viewer.userId)!;
    return users.get(otherId)?.avatarUrl ?? defaultAvatar();
  }
  return autoCompositeAvatar(room.members, users); // 例: 上位2名の複合サムネ
}
```

---

## 3人以上の未設定時のデフォルト表示（推奨）

- **タイトル**: 先頭2〜3名の名前＋「ほかN名」。
- **アイコン**:
  代表2名の複合（タイル/重ね）サムネ、またはメンバー頭文字グリッド。

---

## 検索・フィルタ（ユーザー等での絞り込み）

### 目的

- ルーム一覧を「参加ユーザー」「人数」「名前/アイコンの有無」などで柔軟に絞り込む。
- DM/グループの概念は導入せず、**トークルーム単一モデル上のファセット検索**として提供。

### クイックビュー：『人とのトーク』（ユーザーのDM的扱い）

- **定義**: 次の条件を満たすルームのみを一覧化

  - 閲覧者が現在メンバーである
  - メンバー数が**2人**
  - ルームの**名前/アイコンが未設定**（自動生成は未設定扱い）
- **エントリポイント**

  - ホーム上部のチップ/タブ: 「人とのトーク」
  - サイドバーの固定セクション: 「人とのトーク」
  - 検索バーのクイックサジェスト（`@誰々 とのトーク`）

#### UIレイアウト（見た目）

> 目的:
> \*\*「これまでのトークをすぐ表示」＋「新しいトークを開始」\*\*を同じ面で直観的に。

- **ヘッダー**

  - タイトル: 「人とのトーク」
  - サブコピー: 「過去の1:1を表示。相手を選べば新しいトークを開始できます」
- **上部: 検索／開始インプット**（コンボボックス）

  - プレースホルダ: 「ユーザー名・メールで検索」
  - 入力中:
    候補リストに「◯◯さんとのトークを開く（既存あり）」または「◯◯さんとのトークを開始（新規）」を表示
  - 右側に主要アクション: **「新しいトークを開始」**（選択したユーザーで実行）
- **中段: これまでのトーク**（最近の順リスト）

  - 各行: 相手のアバター／相手の表示名／最終メッセージ抜粋／最終時刻／未読バッジ
  - 行クリック: 既存の1:1未設定ルームを開く
- **下部: 新しいトークの開始**

  - 「よく連絡する人」チップ群（最近の相手トップN）
  - **FAB**（モバイル）: 右下に「＋ 新しいトーク」

#### 状態遷移（動作ルール）

1. **既存がある**: 選択ユーザーとの未設定1:1ルームが存在→そのルームを開く
2. **既存がない**: 未設定1:1ルームを作成して開く
3. **ブロックなどで不可**: トーストで理由提示＋アクション（ブロック解除/申請）
4. **複数候補**:
   同名ユーザーが複数いる場合は候補カードで区別情報（部門・メール）を表示

#### 空状態

- 文言:
  「人とのトークはまだありません。検索欄からユーザーを選んでトークを開始しましょう。」
- ガイド: サンプルアバターの並び＋「ユーザーを検索」ボタン

### UI（例）

- **ユーザーで絞り込み**: ユーザーピッカー（複数選択可）。

  - マッチ方式トグル: `すべて含む（AND）` / `いずれか含む（OR）` / `除外`。
  - 追加オプション: `現在のメンバーのみ` /
    `過去に在籍したことがあるメンバーも含む`。
- **人数**: `ちょうど1:1` / `2人以上` / `3人以上`。
- **名前/アイコン**: `名前あり` / `アイコンあり` / `未設定`。
- **その他（任意）**:
  `未読のみ`、`@自分へのメンションあり`、`ピン留め`、`ミュート除外`、`期間（最終メッセージ時刻）`。
- クイックフィルタ: ユーザープロフィールから「このユーザーとのトークを表示」。

### データモデル補助

- 正規化テーブル `room_members(room_id, user_id, is_current)` を用意。
- ビュー/集計:
  `members_count_current`、`last_message_at`、`has_user_set_name/icon`（派生）を保持。
- ユーザー別状態
  `room_user_state(user_id, room_id, unread_count, pinned, muted, last_seen_at)`（任意）。

### API 例

```
GET /rooms?participants=u1,u2&match=all&includeFormer=false&hasName=false&members=eq:2
GET /rooms?participants=u3&match=any&unreadOnly=true&since=2025-01-01
```

- `participants`: ユーザーIDのカンマ区切り
- `match`: `all`(AND) / `any`(OR) / `none`(除外)
- `includeFormer`: 退室済みも検索対象にするか
- `hasName` / `hasIcon`: `true|false`
- `members`: `eq:2` / `ge:3` など

### 実装メモ（DB層）

- 実装はORM/クエリビルダでOK。AND/OR/除外のロジックはAPI例に準拠。
- インデックス設計や派生カラムの考え方は「パフォーマンス」節を参照。

### 検索式（任意・高度）

- 文字列検索でのクエリ例: `in:@alice @bob mode:all members:eq:2 has:name:false`

  - `in:@user`
    は参加者指定、`mode:all|any|none`、`members:eq:2|ge:3`、`has:name|icon:true|false`。

### パフォーマンス

- `room_members(room_id, user_id, is_current)` に複合INDEX。
- 頻出条件（1:1 / hasName / hasIcon / members\_count\_current /
  last\_message\_at）を**派生カラム**として保持しINDEX。
- モバイル向けは最近アクティブなルームのみをキャッシュ、フィルタ時は必要に応じてサーバ検索。

---

## エッジケース

- 2人→3人に増やした直後に**名前/アイコン未設定**のままでもOK（自動生成表示に切替）。
- 2人ルームで一度**ルーム名/アイコンを設定**してから**解除**した場合 →
  再び相手プロフィール表示に戻る。
- メンバーが1人になったルームは**アーカイブ扱い**。再参加で復帰（表示は上記ルールに従う）。
