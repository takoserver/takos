# トークルーム仕様（単一モデル／表示フォールバック）

## 目的

* **DM/グループという区別を設けず**、すべてを「トークルーム」として扱う。
* 2人のルームで**ルーム名/アイコンが未設定**\*\*なら、各ユーザーにとっての**相手の名前・アイコンをそのまま表示**\**\*する。*
* ルームに**名前またはアイコンが設定されている場合は常にそれを表示**する（人数に関わらず）。
* プロトコル拡張は使わず、**アプリ層メタデータと現在状態のみ**で成立させる。
* さらに、ユーザーが**自分視点で“DM的な扱いを受けているトークルーム”をワンタップで表示**できる直観的なUI（クイックビュー）を提供する。

## スコープ

* クライアント/サーバのアプリ層仕様（MLSはアプリメッセージでイベント配送するだけ）。

---

## 表示の基本ルール

1. ルームにユーザー設定の**名前/アイコン**がある → **それを表示**。
2. ルーム名/アイコンが**未設定**かつ**メンバーがちょうど2人** → **各ユーザーに対して相手のプロフィール（名前・アイコン）を表示**。
3. それ以外（例: 3人以上で未設定） → **自動生成表示**（例: メンバーの頭文字/複合アイコン、タイトルはメンバー名の簡易列挙）。

> 注: 自動生成名/アイコンは“未設定扱い”。ユーザーが明示入力/変更した場合のみ「設定あり」。

---

## データモデル（アプリ層）

**Room（永続）**

```json
{
  "roomId": "r1",
  "members": ["u1", "u2"],
  "displayName": null,          // ユーザー設定のルーム名。未設定なら null
  "displayIcon": null,          // ユーザー設定のルームアイコンURL等。未設定なら null
  "userSet": { "name": false, "icon": false }, // ユーザーが明示設定したか
  "createdAt": 1730000000
}
```

**User（参照）**

```json
{ "userId": "u1", "profileName": "山田 太郎", "avatarUrl": "https://..." }
```

**Event（任意：監査/同期）**

```json
{ "type": "NameSet",      "value": "プロジェクトA", "by": "u1", "ts": 1730000300 }
{ "type": "NameCleared",  "by": "u1",               "ts": 1730000400 }
{ "type": "IconSet",      "value": "https://...",   "by": "u1", "ts": 1730000500 }
{ "type": "IconCleared",  "by": "u1",               "ts": 1730000600 }
{ "type": "MemberAdded",  "userId": "u3",           "by": "u1", "ts": 1730000100 }
{ "type": "MemberRemoved","userId": "u3",           "by": "u1", "ts": 1730000200 }
```

---

## UIフロー（作成/編集）

* **「〇〇さんとのトークを開始」**: 相手を選ぶだけで作成（2人・未設定）。→ 表示は相手のプロフィール。
* **「グループを作成」**: 別メニューで**名前・アイコンを設定**（必須 or 推奨）。→ 常にルーム名/アイコンを表示。
* 途中から**名前/アイコンを設定/解除**できる（解除すると未設定扱いに戻り、2人なら相手表示にフォールバック）。

---

## 表示用ロジック（擬似コード）

```ts
function roomTitleFor(viewer: User, room: Room, users: Map<UserId, User>): string {
  if (room.userSet.name && room.displayName) return room.displayName;
  if (room.members.length === 2) {
    const otherId = room.members.find(id => id !== viewer.userId)!;
    return users.get(otherId)?.profileName ?? "（名称未設定）";
  }
  return autoTitleFromMembers(room.members, users); // 例: 「太郎さん他3名」
}

function roomAvatarFor(viewer: User, room: Room, users: Map<UserId, User>): string|CompositeAvatar {
  if (room.userSet.icon && room.displayIcon) return room.displayIcon;
  if (room.members.length === 2) {
    const otherId = room.members.find(id => id !== viewer.userId)!;
    return users.get(otherId)?.avatarUrl ?? defaultAvatar();
  }
  return autoCompositeAvatar(room.members, users); // 例: 上位2名の複合サムネ
}
```

---

## 3人以上の未設定時のデフォルト表示（推奨）

* **タイトル**: 先頭2〜3名の名前＋「ほかN名」。
* **アイコン**: 代表2名の複合（タイル/重ね）サムネ、またはメンバー頭文字グリッド。

---

## 同期とE2E

* 名前/アイコン変更やメンバー追加/削除などのイベントは、**MLSのアプリメッセージ**として暗号化配送（原則）。
* （任意）配信・検索・重複防止のために、**AAD に最小メタ**を平文でミラーしてもよい（下記「AADミラー」を参照）。AAD は**認証のみで暗号化されない**点に注意。

### AADミラー（任意）：名前とアイコンURLをそのまま含める

* **目的**：サーバ側での高速なルーティング／検索／同一ルーム検出のため、E2E復号なしに参照できる最小情報を持たせる。
* **入れる内容**：**ルーム名（text）** と **アイコンURL（string）** を**そのまま**格納。
* **例**（`authenticated_data` に格納する JSON；1KB 未満推奨）

```json
{
  "t": "room_meta_v1",
  "name": "プロジェクトA",
  "icon_url": "https://cdn.example.com/rooms/r1/icon.png"
}
```

* **注意**

  * AADは中継・配信サーバから**見える**ため、機微情報は載せない（個人情報やトークン付きURLは禁止）。
  * アイコンが秘匿対象なら、**暗号化オブジェクト（ストレージ）＋復号鍵はアプリメッセージで配布**に切替。
  * クライアントは**アプリメッセージの状態をソース・オブ・トゥルース**とし、AADは整合用のヒント。差異があれば次回送信でAADを更新。
  * AADの利用は**設定でON/OFF**可能（法域・ポリシーに合わせて無効化できるように）。

---

## 移行

* 既存の「DM/グループ」フラグは廃止。
* ルーム名/アイコンが**設定済み**ならそのまま表示。未設定なら、

  * **2人**: 相手プロフィールへフォールバック
  * **3人以上**: 自動生成表示

---

## オプション（実装チューニング）

* **1:1の重複防止**: 同一ペアの未設定1:1ルームは再利用（サーバで `{me, other}` 検索）。
* **自動生成名の保存先**: 永続化しない（表示専用）か、別フィールドにキャッシュ。
* **プロフィール変更連動**: 相手のプロフィール名/アイコンが更新された場合、1:1未設定ルームの表示にも即反映。

---

## トップスライダー（セグメント）：すべて / 友だち / グループ

### ねらい

* 一番上に**スライド式のセグメントUI**を置き、ワンタップ/スワイプで「すべて」「友だち」「グループ」を行き来できるようにする。
* 単一モデルのまま、**見せ方＝フィルタのプリセット**として提供（データ構造は分けない）。

### セグメント定義（フィルタ条件）

* **すべて**: 閲覧者が現在メンバーの全ルーム。
* **友だち**: 次のすべてを満たすルーム（= ユーザーのDM的扱い）

  * メンバー数が**ちょうど2人**
  * ルームの**名前/アイコンが未設定**（自動生成は未設定扱い）
* **グループ**: 上記以外（= **3人以上**または**名前/アイコンが設定済み**）

### レイアウト & 挙動

* **ヘッダー**にセグメント（3つのタブ + スライドアンダーライン）。
* **スワイプ**で左右に切替、**タップ**でも切替。デスクトップは**左右矢印キー**操作も可。
* 各タブに**未読バッジ**（合計未読。0なら非表示）。
* **最後に選んだタブを記憶**（ユーザー×デバイス）。
* **ディープリンク**: `/rooms?seg=all|people|groups` で直接そのタブを開く。
* **スクロール位置をタブごとに保持**。切替時はスムーズに復帰。

### アクセシビリティ

* `role="tablist"`/`tab`/`tabpanel` を実装。フォーカスリング/コントラストを担保。
* キーボード: `←/→` でタブ移動、`Enter/Space` で選択。
* 読み上げ: タブに「未読N件」を含むARIAラベル。

### パフォーマンス

* 各セグメントごとに**最近の上位N件を先読み**、下に向けて**仮想化リスト**で増分ロード。
* バッジ用の未読合計は**非同期で集計**し、タブ描画後に反映（ジャンプ抑止）。

### 空状態

* **友だち**: 「1:1のトークはまだありません。ユーザーを選んで開始しましょう」＋開始ボタン。
* **グループ**: 「グループはまだありません。『グループを作成』から始めましょう」。

### クイックアクション

* セグメント右端に **「＋ 新しいトーク」**（2人開始）と **「＋ グループ作成」** のショートカット。
* 検索バーを常時表示し、セグメントの条件に**追加で**ANDフィルタできる。

---

## 検索・フィルタ（ユーザー等での絞り込み）

### 目的

* ルーム一覧を「参加ユーザー」「人数」「名前/アイコンの有無」などで柔軟に絞り込む。
* DM/グループの概念は導入せず、**トークルーム単一モデル上のファセット検索**として提供。

### クイックビュー：『人とのトーク』（ユーザーのDM的扱い）

* **定義**: 次の条件を満たすルームのみを一覧化

  * 閲覧者が現在メンバーである
  * メンバー数が**2人**
  * ルームの**名前/アイコンが未設定**（自動生成は未設定扱い）
* **エントリポイント**

  * ホーム上部のチップ/タブ: 「人とのトーク」
  * サイドバーの固定セクション: 「人とのトーク」
  * 検索バーのクイックサジェスト（`@誰々 とのトーク`）

#### UIレイアウト（見た目）

> 目的: \*\*「これまでのトークをすぐ表示」＋「新しいトークを開始」\*\*を同じ面で直観的に。

* **ヘッダー**

  * タイトル: 「人とのトーク」
  * サブコピー: 「過去の1:1を表示。相手を選べば新しいトークを開始できます」
* **上部: 検索／開始インプット**（コンボボックス）

  * プレースホルダ: 「ユーザー名・メールで検索」
  * 入力中: 候補リストに「◯◯さんとのトークを開く（既存あり）」または「◯◯さんとのトークを開始（新規）」を表示
  * 右側に主要アクション: **「新しいトークを開始」**（選択したユーザーで実行）
* **中段: これまでのトーク**（最近の順リスト）

  * 各行: 相手のアバター／相手の表示名／最終メッセージ抜粋／最終時刻／未読バッジ
  * 行クリック: 既存の1:1未設定ルームを開く
* **下部: 新しいトークの開始**

  * 「よく連絡する人」チップ群（最近の相手トップN）
  * **FAB**（モバイル）: 右下に「＋ 新しいトーク」

#### 状態遷移（動作ルール）

1. **既存がある**: 選択ユーザーとの未設定1:1ルームが存在→そのルームを開く
2. **既存がない**: 未設定1:1ルームを作成して開く
3. **ブロックなどで不可**: トーストで理由提示＋アクション（ブロック解除/申請）
4. **複数候補**: 同名ユーザーが複数いる場合は候補カードで区別情報（部門・メール）を表示

#### 空状態

* 文言: 「人とのトークはまだありません。検索欄からユーザーを選んでトークを開始しましょう。」
* ガイド: サンプルアバターの並び＋「ユーザーを検索」ボタン

### UI（例）

* **ユーザーで絞り込み**: ユーザーピッカー（複数選択可）。

  * マッチ方式トグル: `すべて含む（AND）` / `いずれか含む（OR）` / `除外`。
  * 追加オプション: `現在のメンバーのみ` / `過去に在籍したことがあるメンバーも含む`。
* **人数**: `ちょうど1:1` / `2人以上` / `3人以上`。
* **名前/アイコン**: `名前あり` / `アイコンあり` / `未設定`。
* **その他（任意）**: `未読のみ`、`@自分へのメンションあり`、`ピン留め`、`ミュート除外`、`期間（最終メッセージ時刻）`。
* クイックフィルタ: ユーザープロフィールから「このユーザーとのトークを表示」。

### データモデル補助

* 正規化テーブル `room_members(room_id, user_id, is_current)` を用意。
* ビュー/集計: `members_count_current`、`last_message_at`、`has_user_set_name/icon`（派生）を保持。
* ユーザー別状態 `room_user_state(user_id, room_id, unread_count, pinned, muted, last_seen_at)`（任意）。

### API 例

```
GET /rooms?participants=u1,u2&match=all&includeFormer=false&hasName=false&members=eq:2
GET /rooms?participants=u3&match=any&unreadOnly=true&since=2025-01-01
```

* `participants`: ユーザーIDのカンマ区切り
* `match`: `all`(AND) / `any`(OR) / `none`(除外)
* `includeFormer`: 退室済みも検索対象にするか
* `hasName` / `hasIcon`: `true|false`
* `members`: `eq:2` / `ge:3` など

### 実装メモ（DB層）

* 実装はORM/クエリビルダでOK。AND/OR/除外のロジックはAPI例に準拠。
* インデックス設計や派生カラムの考え方は「パフォーマンス」節を参照。

### 検索式（任意・高度）

* 文字列検索でのクエリ例: `in:@alice @bob mode:all members:eq:2 has:name:false`

  * `in:@user` は参加者指定、`mode:all|any|none`、`members:eq:2|ge:3`、`has:name|icon:true|false`。

### パフォーマンス

* `room_members(room_id, user_id, is_current)` に複合INDEX。
* 頻出条件（1:1 / hasName / hasIcon / members\_count\_current / last\_message\_at）を**派生カラム**として保持しINDEX。
* モバイル向けは最近アクティブなルームのみをキャッシュ、フィルタ時は必要に応じてサーバ検索。

---

## エッジケース

* 2人→3人に増やした直後に**名前/アイコン未設定**のままでもOK（自動生成表示に切替）。
* 2人ルームで一度**ルーム名/アイコンを設定**してから**解除**した場合 → 再び相手プロフィール表示に戻る。
* メンバーが1人になったルームは**アーカイブ扱い**。再参加で復帰（表示は上記ルールに従う）。
